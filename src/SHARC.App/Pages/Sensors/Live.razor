@page "/sensors/{sharcId}/live"
@inherits TrakHoundComponentBase
@layout Layout
@using TrakHound.Requests
@using System.Text.Json.Serialization

<TrakHoundPageTitle>@GetPageTitle()</TrakHoundPageTitle>

<div class="page">
    <div class="breadcrumb-panel">
        <BreadcrumbLinks>
            <BreadcrumbLink Display="Sensors" Link="@GetPath("/")"></BreadcrumbLink>
            <BreadcrumbLink Display="@SharcId"></BreadcrumbLink>
        </BreadcrumbLinks>
    </div>
    <div class="page-sidebar">
        <Sidebar SharcId="@SharcId" />
    </div>
    <div class="page-content">

        <div class="toolbar-panel">
            <div class="toolbar-container">
                <RadzenDropDown TValue="string" Data="@sensorNames" @bind-Value="@selectedSensorName" Placeholder="Select Sensor.." />
            </div>
            <div class="toolbar-container">

                @if (!loading && consumer == null)
                {
                    <button class="btn btn-primary btn-query" @onclick="Subscribe"><span class="icon fa-solid fa-sharp fa-magnifying-glass"></span>Subscribe</button>
                }
                else
                {
                    <button class="btn btn-light btn-query" @onclick="Unsubscribe"><span class="icon fa-solid fa-pause"></span>Unsubscribe</button>
                    <div class="listening">
                        <ListeningIndicator />
                    </div>
                }

            </div>
        </div>

        @if (!loading)
        {
            @if (resultSuccess != null)
            {
                var resultIcon = resultSuccess.Value ? "fa-solid fa-sharp fa-check" : "fa-solid fa-sharp fa-circle-xmark";
                var resultClass = resultSuccess.Value ? "success" : "error";

@*                 <div class="status-panel @resultClass">
                    <span class="status-icon @resultIcon"></span>
                    <span class="status-message">@resultMessage</span>
                </div> *@

                if (resultSuccess.Value)
                {
                    var items = bufferItems.Get()?.ToList().Take(bufferIndex);
                    if (!items.IsNullOrEmpty())
                    {
                        //var chartItems = items.Reverse();
                        var chartItems = GetChartItems(items);
                        var tableItems = items.OrderByDescending(o => o.Timestamp);

                        <div class="content-panel">
                            <RadzenSplitter Orientation="Orientation.Vertical">
                                <RadzenSplitterPane Min="100px">
                                    <div class="chart-panel">
                                        <RadzenChart>
                                            <RadzenLineSeries Data="@chartItems" CategoryProperty="Timestamp" Title="@selectedSensorName" ValueProperty="Value" Stroke="var(--accentLight)" StrokeWidth="3" />
                                             <RadzenLegend Visible="false" />
                                            <RadzenCategoryAxis Formatter="@GetCategoryAxisLabel" Min="@from" Max="@to" Step="@GetCategoryAxisStep()">
                                                <RadzenGridLines Visible="true" />
                                            </RadzenCategoryAxis>
                                            <RadzenValueAxis Formatter="@GetValueAxisLabel" Min="@min" Max="@max"  >
                                                <RadzenGridLines Visible="true" />
                                                <RadzenAxisTitle Text="@sensorModel?.Units" />
                                            </RadzenValueAxis>
                                        </RadzenChart>
                                    </div>
                                </RadzenSplitterPane>
                                <RadzenSplitterPane Min="100px">
                                    <div class="table-panel">
                                        <RadzenDataGrid Data="@tableItems"
                                                        TItem="ValueItem"
                                                        Density="Density.Compact"
                                                        AllowVirtualization="true"
                                                        GridLines="DataGridGridLines.Vertical">
                                            <Columns>
                                                <RadzenDataGridColumn TItem="ValueItem" Property="SensorName" Title="SensorName" Width="100px" />
                                                <RadzenDataGridColumn TItem="ValueItem" Property="Timestamp" Title="Timestamp" Width="180px" />
                                                <RadzenDataGridColumn TItem="ValueItem" Title="Offset" Width="180px">
                                                    <Template Context="context">
                                                        <span>@GetOffsetDebug(context.Timestamp)</span>
                                                    </Template>
                                                </RadzenDataGridColumn>
                                                <RadzenDataGridColumn TItem="ValueItem" Property="Value" Title="Value" />
                                            </Columns>
                                        </RadzenDataGrid>
                                    </div>
                                </RadzenSplitterPane>
                            </RadzenSplitter>
                        </div>
                    }
                }
            }
        }
        else
        {
            <div class="loading-panel">
                <Loading Message="@loadingMessage" />
            </div>
        }

    </div>
</div>

@code {

    private const int bufferSize = 100;

    private TrakHoundSharcModel sharcModel;
    private SharcSensorInformation sensorModel;
    private ITrakHoundConsumer<ValueModel> consumer;

    private bool? resultSuccess;
    private string resultMessage;

    private DateTime from;
    private DateTime to;
    private double max = double.MinValue;
    private double min = double.MaxValue;
    private TimeSpan window = TimeSpan.FromSeconds(60);
    private TimeSpan interval = TimeSpan.FromMilliseconds(50);

    private CircularBuffer<ValueItem> bufferItems = new CircularBuffer<ValueItem>(bufferSize);
    private int bufferIndex;
    private System.Timers.Timer updateTimer;

    private IEnumerable<string> sensorNames;
    private string selectedSensorName;

    private bool loaded = false;
    private bool loading = true;
    private string loadingMessage = "Loading Sensors..";


    struct ValueItem
    {
        public string SensorName { get; set; }
        public double Value { get; set; }
        public DateTime Timestamp { get; set; }
    }

    class SharcSensorInformation
    {
        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("description")]
        public string Description { get; set; }

        [JsonPropertyName("units")]
        public string Units { get; set; }
    }

    class ValueModel
    {
        [JsonPropertyName("v")]
        public double Value { get; set; }

        [JsonPropertyName("t")]
        public DateTime Timestamp { get; set; }
    }


    [Parameter]
    public string SharcId { get; set; }


    protected async override Task OnInitializedAsync()
    {
        await Load();
    }

    private async void QueryClicked()
    {
        await Load(true);
    }

    private async Task Load(bool forceLoad = false)
    {
        if (forceLoad || !loaded)
        {
            sharcModel = null;
            sensorModel = null;
            sensorNames = null;

            resultSuccess = null;
            resultMessage = null;

            loaded = true;
            loading = true;
            loadingMessage = "Loading Sensor..";
            await InvokeAsync(StateHasChanged);

            sharcModel = await Client.Api.QueryJson<TrakHoundSharcModel>($"sharc/api/{SharcId}");

            sensorNames = await Client.Api.QueryJson<IEnumerable<string>>($"sharc/api/{SharcId}/io");

            loading = false;
            loadingMessage = null;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task Subscribe()
    {
        if (!string.IsNullOrEmpty(selectedSensorName))
        {
            sensorModel = await Client.Api.QueryJson<SharcSensorInformation>($"sharc/api/{SharcId}/io/{selectedSensorName}");

            resultSuccess = true;

            consumer = await Client.Api.SubscribeJson<ValueModel>($"sharc/api/{SharcId}/io/{selectedSensorName}/values");
            if (consumer != null)
            {
                consumer.Received += ValueReceived;

                to = DateTime.Now;
                from = to - window;

                updateTimer = new System.Timers.Timer();
                updateTimer.Interval = interval.TotalMilliseconds;
                updateTimer.Elapsed += UpdateTimerElapsed;
                updateTimer.Start();
            }
        }
    }

    private async Task Unsubscribe()
    {
        if (consumer != null) consumer.Dispose();
        consumer = null;

        if (updateTimer != null) updateTimer.Dispose();

        await InvokeAsync(StateHasChanged);
    }

    private void ValueReceived(object sender, ValueModel model)
    {
        var item = new ValueItem();
        item.SensorName = selectedSensorName;
        item.Value = model.Value;
        item.Timestamp = model.Timestamp;
        // item.Timestamp = DateTime.Now;
        bufferItems.Add(item);

        if (model.Value > max) max = model.Value + (model.Value * 0.1);
        if (model.Value < min) min = model.Value - (model.Value * 0.1);

        bufferIndex++;
        bufferIndex = Math.Min(bufferSize - 1, bufferIndex);
    }

    private async void UpdateTimerElapsed(object sender, System.Timers.ElapsedEventArgs args)
    {
        from = from.Add(interval);
        to = to.Add(interval);

        await InvokeAsync(StateHasChanged);
    }

    private ValueItem[] GetChartItems(IEnumerable<ValueItem> items)
    {
        double lastValue = 0;

        var a = items.Reverse().ToArray();
        var chartItems = new ValueItem[a.Length * 2];

        var x = 0;
        for (var i = 0; i < a.Length; i++)
        {
            var firstItem = new ValueItem();
            firstItem.Value = a[i].Value;
            firstItem.Timestamp = a[i].Timestamp;
            chartItems[x] = firstItem;
            lastValue = firstItem.Value;
            x++;

            if (i < a.Length - 1)
            {
                var secondItem = new ValueItem();
                secondItem.Value = a[i].Value;
                secondItem.Timestamp = a[i + 1].Timestamp;
                chartItems[x] = secondItem;
                x++;
            }
            else
            {
                var secondItem = new ValueItem();
                secondItem.Value = a[i].Value;
                secondItem.Timestamp = to;
                chartItems[x] = secondItem;
                x++;
            }
        }

        // var lastItem = new ValueItem();
        // lastItem.Value = lastValue;
        // lastItem.Timestamp = to;
        // chartItems[x] = lastItem;
        // x++;

        return chartItems;
    }


    private string GetPageTitle()
    {
        return $"SHARC - {SharcId}";
    }


    private string GetValueAxisLabel(object value)
    {
        return value.ToString();
        // return ((double)value).ToString("N2");
    }

    private string GetCategoryAxisLabel(object value)
    {
        var timestamp = ((DateTime)value);

        if (timestamp > to.AddSeconds(-2.5)) // Subtract 1/2 Axis Step
        {
            return timestamp.ToString("hh:mm:ss.fff tt");
        }
        else
        {
            return GetOffset(timestamp);
        }
    }

    private object GetCategoryAxisStep()
    {
        return TimeSpan.FromSeconds(5);
    }

    private string GetOffset(DateTime timestamp)
    {
        return $"-{(to - timestamp).ToString("mm\\:ss")}";
        // return $"-{(to - timestamp).ToString("ss\\.ff")}";
    }

    private string GetOffsetDebug(DateTime timestamp)
    {
        return $"-{(to - timestamp).ToString()}";
    }

}
